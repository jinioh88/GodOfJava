# 자바의신 정리파일
  - 자바의신 책을 보며 메모하는 리파지토리
  - 개인 공부용이라 자세한 내용이 궁금하면 책을 참고하시길...

## 변수의 종류
  - 지역변수
    - 중괄호 내에서 선언된 변수
    - 중괄호 내에서만 유효
  - 매개 변수
    - 메소드에 넘겨주는 변수
    - 메서드가 호출될 때 생명이 시작되고, 메서드가 끝나면 소멸.
  - 인스턴스 변수
    - 메서드 밖에, 클래스 안에 선언된 변수. static 예약어가 없어야 함.
    - 객체가 생성될 때 생명이 시작되고, 그 객체를 참조하고 있는 다른 객체가 없으면 소멸.
  - 클래스 변수
    - 메서드 밖에, 클래스 안에 선언된 변수. static 예약어가 붙은거. 
    - 클래스가 처음 호출될 때 생명이 시작되고, 자바 프로그램이 끝날 때 소멸.

## 변수의 자료형
  - String은 참조 자료형이지만 new를 사용해 객체를 생성하지 않아도 되는 유일한 리턴타입이다.
    > String bookName = "hahahaha";
  - 자바에서 돈계산 괸련된건 정확성 떄문에 BigDecimal 사용한다. float, double 안씀.

## 기본형 자료형
  - 자바의 모든 자료형은 기본형이 있지만, 지역변수로 기본 자료형을 사용할 땐 반드시 값을 지정해야 한다. (사용하지 않을땐 컴파일 에러 안남)

## 조건
  - if 문장이 하나라도 중괄호를 열고 닫는 습관을 들이자. 가독성이 좋아진다. 
  - 학점, 이자 계산 같이 하나의 값이 여러 범위에 걸쳐 비교될 때는 switch 구문 사용이 좋다. 
  - switch
    - 비교 대상의 값에 범위가 있으면 if를 사용하는 것이 좋고, 특정 조건에 따른 처리를 해야할 경우 switch문이 좋다. 
    - default는 맨 뒤에 넣는 것을 권장한다. 
    - 숫자 비교시 작은 숫자부터 증가 시켜 나가는게 좋다. 
  - label
    - 두개 이상의 for나 while 루프가 있을때 아주 가끔 사용된다. 

## 배열
  - 지역변수의 경우 초기화를 하지 않으면 사용이 불가한데, 배열의 경우는 크기만 잡아주면 초기화 하지 않아도 각 배열의 기본값이 할당 된다. 
  - 참조 자료형은 초기화 하지 않으면 null이 된다. 
  - 중괄호를 사용해 초기화 할 땐 반드시 한번에 변수 선언 및 초기화가 이뤄져야 한다. 
  - 중괄호는 보통 절대 변경되지 않는 값을 지정할 때 선언하여 사용한다. 
    - (ex 달 --> 달처럼 변하지 않는 값은 메소드 내에 사용하는 것 보단 클래스 변수로 선언해 재활용 하는게 좋다. 
    - 단 메서드 하나에서만 이 달 배열을 사용하면 반드시 메소드 밖으로 뺼 필요는 없다...(메모리 문제 등등)
    - 위를 해결하려면 static 예약어를 활용하면 된다. 
  - 2차원 배열은 웬만하면 사용하지 않는 걸 권장한다. 
  - .length를 사용해 for 루프가 수행될 때마다 길이를 얻어오는 것은 성능 적 측면서 별로 좋지 않다. 
    > for(int one=0; one < twoDim.lenth; one++) ...
    - 다음 과 같이 수정하즈아
    >
        int len = twoDim.length;
        for(int one=0; one < len; one++)...
  - 2차원 for 루프
    >
        int[][] arr = {{1,2,3}, {4,5,6}};
        for(int[] dimArr : arr) {
          for(int data : dimArr) {
            System.out.print(data);
          }
        }
  - 배열의 값만을 처리할 수 있을 때 위처럼 향상된 배열 표현법을 쓰는게 편리하다. 
    - 하지만 1차원 배열과 2차원 배열의 위치를 모른다는 단점이 있다...
    - 위치를 확인 하려면 임시 변수를 두어야 한다. 
  - 값만 처리하기 위한 배열은 향상된 for루프를, 배열의 위치 정보도 같이 필요한 배열은 기본 for 루프를 사용하는게 편리하다. 
  - 배열은 무조건 선언할때 크기가 지정되어야 한다. 중간에 배열 크기를 감소 증가 할 수 없다. 이런 단점 보안을 위해 나온게 Collection이다. 

## 참조 자료형
  - 인스턴스 변수들을 선언한 후 생성자를 위치시키고, 그 다음 필요하나 메서드를 위치 시키자. 
  - 자바 패턴 중에 DTO, VO 라는 것이 있다.
    - DTO : 어떤 속성을 갖는 클래스를 만들고, 그 속성을 쉽게 전달하기 위해 만든 것. 데이터를 다른 서버로 전달하기 위한 것이 주 목적.
    - VO : DTO와 형태는 비슷하나, 데이터를 담아 두기 위한 목적으로 사용. 
    - DTO를 만드는 이유는 클래스안의 복잡한 데이터를 리턴할 때 DTO를 만들어 메소드의 리턴 타입에 DTO로 선언하고 그 객체를 리턴하면 편리하기 떄문이다. 
      >   public MemberDTO getMemberDto() {...}
  - 생성자는 꼭 필요에 맞는 생성자만 만드는 습관을 들이자. 
  - 함수의 리턴 타입은 하나인데, 여러개를 넘겨주고 싶으면 DTO를 사용하라.
  - 리턴값이 void 인 경우 'return;' 이렇게 해주면 메서드 수행을 종료해 라는 의미이다. 
  - static 메서드
    - 클래스 변수만 사용할 수 있다는 단점이 있따. 
  - static 블록
    - 객체는 여러개 생성하지만, 한 번만 호출되어야 하는 코드가 있다면 static 블록을 사용하면 된다. 
    - 객체가 생성되기 전에 한 번만 호출 되고, 그 이후엔 호출 되지 않는다. 
    - 클래스 내에 선언되있어야 하고, 메서드 내에서 선언될 수 없다. 
    - 클래스를 초기화 할 때 꼭 수행되야 하는 작업이 있을 경우 유용하다. 
  - Pass by Value는 호출되기 전과 후에 데이터가 변경되지 않는다.
    - 참조변수일 경우에도 호출된 메서드에서 다른 객체로 대체하여 처리하면(new ~) 기존 값은 바뀌지 않는다. 
  - Pass by Reference
    - 매개 변수로 받은 참조 자료형 안에 있는 객체를 변경하면, 호출한 참조 자료 형 안에 있는 객체는 호출된 메서드에서 변경한 대로 데이터가 바뀐다. 
  - 매개 변수 지정하기
    - 매개 변수가 갯수가 유동적이라면 배열로 넘겨주는 방법이 있다. 매개 변수 넘겨줄 땐 배열을 만든 후 넘겨줘야 하는 불편함이 있다.  
    - 위는 불편함이 있어 자바에선 임의의 매개 변수를 넘겨줄 방법을 제공한다. "타입...변수명"으로 선언해 주면 배열로 인식해 준다.
    - 필요에 따라 매개 변수 수를 정하기 애매한 경우 사용한다. 
    - 이 매개 변수는 다른 매개 변수들 쓰고, 가장 마지막에 선언해야 한다. 
      >   pubilc void atrb(String message, int... numbers)
  
## 등가교환 연산자
  - 기본 자료형은 같은 종류끼리 비교가 가능하다.
  - char == int, double == int, boolean == boolean 같이 비교할 수 있다. 
  - boolean == int 는 안된다. 


## 패키지
  - 패키지 이름은 java로 시작하면 안된다. 컴파일은 되지만 실행이 안된다. 
  - 패키지 이름은 모두 소문자로 지정해야 한다. 
  - 자바 예약어를 사용하면 안된다. 
  - 자바 패키지가 있을 때, 같은 패키지에 있는 클래스들과 java.lang 패키지에 있는 클래스들만 찾을 수 있다. 
  - 다른 패키지에 있는 클래스를 찾지 못할 경우 import 예약어를 사용한다. 
  - JDK 5부터 import static 이라는 것이 추가 됬는데, static한 변수와 satic 메서드를 사용하고자 할 때 용이하다. 
      > 
          // c.javapackage.sub.SubStatic.java에 static 변수 CLASS_NAME과 static함수 subStaticMethod()가 있다고 할때.
          // imort static이 없다면 SubStatic.CLASS_NAME, SubStatic.subStaticMethod() 이런 식으로 물러오지만
          // import static 이 있다면 System.out.println(CLASS_NAME);  subStaticMethod() 처럼 바로 쓸 수 있다. 

## 접근 제어자
  - public
    - 누구나 접근할 수 있도록 할 때 사용
  - protected
    - 같은 패키지에 있거나 상속받는 경우 접근할 수 있다.
  - package-private
    - 아무 접근제어자 안적어줄때 이렇게 불린다.
    - 같은 패키지 내에 있을 떄만 접근할 수 있다.
  - private
    - 해당 클래스 내에서만 접근 가능하다. 
  - 클래스 접근 제어자 선언할 때 유의점
    - public으로 선언된 클래스가 소스 내에 있다면, 그 소스 파일의 이름은 public 인 클래스 이름과 동일해야 한다. 

## 상속
  - 상속을 하게 되면 부모 클래스에 선언되 있는 public, protected로 선언된 모든 변수, 메서드를 사용할 수 있다. 
  - 자식클래스의 생성자를 호출하면, 부모 클래스의 기본 생성자가 먼저 호출된다. 
  - 자바는 다중 상속 안된다.
  - 상속과 생성자
    - 자식 클래스의 생성자가 실행할 떄 부모 클래스의 기본 생성자가 없다면 에러가 발생한다.(부모 클래스에 기본 생성자 없고, 매개변수 있는 생성자만 있을 경우)
    - 매개 변수가 있는 생성자를 만들면 기본 생성자는 자동으로 만들어 지지 않기 때문
    - 위의 해결 방법은 2가지가 있다.
      - 부모 클래스에서 기본 생성자를 만들어 준다.
      - 자식 클래스에서 부모 클래스의 생성자를 명시적으로 지정하는 super("매개변수")를 사용한다. 기본 super()는 자식에서 선언 안해도 자동으로 들어간다.
  - 오버라이딩
    - 부모 클래스의 메서드가 자식클래스에도 있다면 오버라이딩 인데, 리턴값을 마음데로 바꾸지 못한다. 
    - 자식클래스에서 접근자는 접근 권한이 부모보다 크거나 같아야 한다. ex) 부모가 public이면 자식이 private면 오류.
  - 참조 자료형의 형변환(다시 보기.. 블로그 정리)
    - 자바 컴파일러에선 자식 객체를 생성할 때 부모 생성자를 사용하면 안된다고 못을 밖았다. 명시적 형변환 해줘야 한다. 
    - 명시적 형 변환을 해도 예외가 발생 할 수 있다. 
      >
          Parent parent = new Parent();
          Child child = new Child();
          Parent parent2 = child;  // 가능
          Child child2 = (Child)parent;   // 형변환 필요. 컴파일은 되지만 예외가 발생한다. 
          Child child3 = (Child)parent2;  // 형변환 필요. 정상 작동한다. parent2가 겉보기엔 Parent 지만 child를 대입해줘 Child로 형변환 됬기 때문 
    - 일반적으로 여러 개의 값을 처리 하거나, 매개 변수로 값을 보낼 땐 보통 부모 클래스의 타입으로 보낸다. 
      - 근데 부모는 넘겨주는 타입이 부모인지 자식인지 모르니 instanceof로 구분한다.
      - instanceof로 타입을 점검할 땐 부모 인스턴스인지 여부르 먼저 점검하면 안된다. 모든 결과가 부로로 찍힐 가능성이...
      - instanceof로 타입 점검할 땐 가장 하위에 있는 자식부터 확인하는게 안전하다. 
  - Polymorphism(다형성))
    - 형 변환을 하더라도, 실제 호출된는 것은 원래 객체에 있는 메서드가 호출된다. 

## Object
  - 모든 클래스는 Object 클래스를 상속 받는데, Object 클레스에 있는 메서드들을 통해 클래스의 기본적인 행동을 정의할 수 있기 떄문이다. 
  - Objectg 클래스에서 제공하는 메서드 종류 
    - 객체를 처리하기 위한 메소드와 쓰레드를 위한 메소드로 나뉜다. 
    - 필요할 떄 이것들은 오버라이딩해서 사용해야 한다. 
      - 오버라이딩이 필요한 떄는 DTO를 사용할 떄 오버라이딩 하면 좋다. 내용확인이 쉽기 떄문. 객체를 비교하기 위함.
  - toString() 메서드
    - 해당 클래스가 어떤 객체인지 쉽게 나타낼 수 있다. 
    - System.out.println() 에 매개변수로 들어가는 경우 toString()이 자동으로 호출된다. 
    - String을 제외한 참조 자료형에 더하기 연산을 수행하면, 자동으로 toString() 메서드가 호출된다. 
  - 객체에 '==' ? 'equals()'
    - 참조자료형에서 '=='는 주소값을 비교한다. 
    - equals()는 오버라이딩 해야지 제대로 비교가 가능해 진다. 안하면 같은 값을 같는 객체라도 hashCode() 값이 달라져 같다고 판단을 안한다. 
    - equals() 오버라이딩할 떈 hashCode()도 같이 오버라이딩 해줘야한다. 
  - hashCode()
    - 객체의 메모리 주소를 16진수로 리턴한다. 
