# 헤드퍼스트 디자인패턴
## 1장 디자인 패턴 소개
  - 소프트웨어를 만들 때 나중에 혹시 고쳐야 할 때도 기존 코드에 미치는 영향은 최소한으로 줄이면서 작업을 할 수 있도록 만들수 있는 방법이 있어야한다. 
  - 자바 인터페이스에는 구현된 코드가 전혀 들어가 있지 않아서 코드 재사용을 할 수 없는 문제점이 있다. flyable인터페이스의 fly()를 모든 오리 종료대로 만들어줘야.
### 소프트웨어 개발에 있어서 바뀌지 않는것.
  - 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다.
  - 바뀌는 부분을 따로 뽑아서 캡슐화 시킨다. 바뀌지 않는 부분에 영향을 미치지 않고 그 부분만 고칠 수 있게된다. 
  - 행동을 동적으로 바꿀 수 있게 하려면 Duck클래스에서 행동과 관련된 setter 메서드를 포함시켜야 한다. 
  - 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다. 
  - Duck클래스에 Flyable과 Quackable의 인스턴스 변수가 있는 구성같이 합치는 것을 '구성'을 이용한 것이라 한다.
  - 디자인 원칙으로 상속 보다는 구성을 활용한다. 
    - 캡슐화 + 실행시 행동을 바꿀 소도 있다. 
### 스트레지 패턴
  - 알고리즘군(Flyable를 구현한 클래스들)을 정의하고 각각을 캡슐화 하여 교환해서 사용할 수 있도록 만드는 패턴. 
  - 알고리즘을 사용하는 클라이언트(Duck)와는 독립적으로 알고리즘을 변경할 수 있다.
### 옵저버 패턴
  - 출판사(주체) + 구독자(옵저버) 라고 생각하면 된다. 
  - 주체의 값이 바뀌면 구독자에게 알린다. 
  - 한객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로, 일대다 의존성을 정의한다. 
  - 옵저버 패턴 구현은 대부분 주제 인터페이스와 옵저버 인터페이스가 들어있는 클래스 디자인을 바탕으로 한다. 
  - 옵저버 패턴에서 주제와 옵저버가 느슨하게 결합되어 있는 객체 디자인을 제공한다. 
  - 서로 상호작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다. 
  - 자바 자체에서도 옵저버 패턴을 일부 지원한다. 
  - 자바 내장 옵저버 패턴
    - 자바에서 몇가지 API를 통해 자체적으로 옵저버 패턴을 지원한다. 
    - java.util 패키지의 Observer 인터페이스와 Observerable 클래스다. 
    - 푸시/풀 방식으로 갱신할 수 있다. 
    - 푸시 방식은 notifyObservers(arg) 형식으로 사용해야 한다. 
    - setChanged()는 상태가 바뀌었다는 것을 밝히는 용도이다. 
    - 옵저버에게 연락이 가는 순서에 의존하면 절대 안된다. 
      - 특정 연락 순서에 의존하도록 코드를 만들었다면 잘못된 것이다. 

### 데코레이션 패턴